(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{382:function(t,a,e){"use strict";e.r(a);var r=e(25),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"四、流（stream）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四、流（stream）"}},[t._v("#")]),t._v(" 四、流（stream）")]),t._v(" "),e("p",[t._v("Node.js 中有四种流，可读流（Readable）、可写流（Writable）、双工流（Duplex）、在读写过程中可以修改和变换数据的 Duplex 流（Transform），所有的流都是 EventEmitter 的实例。")]),t._v(" "),e("h2",{attrs:{id:"缓冲"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓冲"}},[t._v("#")]),t._v(" 缓冲")]),t._v(" "),e("p",[t._v("可读流和可写流都会保存在内部的缓冲器中。")]),t._v(" "),e("p",[t._v("可缓冲区的大小由构造函数中的 hignWaterMark 确定。")]),t._v(" "),e("p",[t._v("当调用 stream.push(chunk) 时，数据会被缓存到可读流中。如果流的消费者没有调用 stream.read() 数据会被保存到内部队列中直到被消费。")]),t._v(" "),e("p",[t._v("一旦缓冲区大小超过 hignWaterMark 规定的值时，流会暂时从底层读取数据到缓冲区，直到缓冲区数据被消费（也就是说，流会停止调用内部的用于填充可读缓冲区的 readable._read()）。")]),t._v(" "),e("p",[t._v("当调用 writable.write(chunk)时，数据会被缓冲在可写流中。当内部的可写缓冲大小小于 hignWaterMark 时，调用 writable.write() 会返回true，否则返回false。")]),t._v(" "),e("p",[t._v("stream.pipe() 是为了限制数据的缓冲可接受程度，也就是读写速度不一致的源头与目的地不会压垮内存。")]),t._v(" "),e("h2",{attrs:{id:"应用层"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#应用层"}},[t._v("#")]),t._v(" 应用层")]),t._v(" "),e("h3",{attrs:{id:"可读流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#可读流"}},[t._v("#")]),t._v(" 可读流")])])}),[],!1,null,null,null);a.default=s.exports}}]);