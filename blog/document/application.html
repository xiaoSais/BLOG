<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>十、代码之如何实现？ | Secret</title>
    <meta name="generator" content="VuePress 1.5.0">
    
    <meta name="description" content="Just playing around">
    <link rel="preload" href="/blog/assets/css/0.styles.d244ddc1.css" as="style"><link rel="preload" href="/blog/assets/js/app.d0f691b7.js" as="script"><link rel="preload" href="/blog/assets/js/2.193d832c.js" as="script"><link rel="preload" href="/blog/assets/js/28.2c3e24f2.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.fe6cbfee.js"><link rel="prefetch" href="/blog/assets/js/11.139d241f.js"><link rel="prefetch" href="/blog/assets/js/12.222ab8bb.js"><link rel="prefetch" href="/blog/assets/js/13.f9d0cf37.js"><link rel="prefetch" href="/blog/assets/js/14.faf6eeb3.js"><link rel="prefetch" href="/blog/assets/js/15.ad5b9b70.js"><link rel="prefetch" href="/blog/assets/js/16.01445cb0.js"><link rel="prefetch" href="/blog/assets/js/17.329331a9.js"><link rel="prefetch" href="/blog/assets/js/18.41a5e146.js"><link rel="prefetch" href="/blog/assets/js/19.f83fcfe6.js"><link rel="prefetch" href="/blog/assets/js/20.5f11b046.js"><link rel="prefetch" href="/blog/assets/js/21.e05837f8.js"><link rel="prefetch" href="/blog/assets/js/22.2ecfae4a.js"><link rel="prefetch" href="/blog/assets/js/23.f78999b8.js"><link rel="prefetch" href="/blog/assets/js/24.42ba54a6.js"><link rel="prefetch" href="/blog/assets/js/25.4cb179fd.js"><link rel="prefetch" href="/blog/assets/js/26.849a1d16.js"><link rel="prefetch" href="/blog/assets/js/27.2e954321.js"><link rel="prefetch" href="/blog/assets/js/29.614e50fd.js"><link rel="prefetch" href="/blog/assets/js/3.9dfa9226.js"><link rel="prefetch" href="/blog/assets/js/30.e7cfa59a.js"><link rel="prefetch" href="/blog/assets/js/31.0739bf20.js"><link rel="prefetch" href="/blog/assets/js/32.ccca9e29.js"><link rel="prefetch" href="/blog/assets/js/33.8781f9fe.js"><link rel="prefetch" href="/blog/assets/js/34.2d587b29.js"><link rel="prefetch" href="/blog/assets/js/35.83d5cca7.js"><link rel="prefetch" href="/blog/assets/js/36.7253c9c7.js"><link rel="prefetch" href="/blog/assets/js/37.486536cb.js"><link rel="prefetch" href="/blog/assets/js/38.1f2fb8a7.js"><link rel="prefetch" href="/blog/assets/js/39.43d80e35.js"><link rel="prefetch" href="/blog/assets/js/4.c1635489.js"><link rel="prefetch" href="/blog/assets/js/40.4b2ac2d3.js"><link rel="prefetch" href="/blog/assets/js/41.60a5f16e.js"><link rel="prefetch" href="/blog/assets/js/42.0eaa7a3d.js"><link rel="prefetch" href="/blog/assets/js/43.1275931a.js"><link rel="prefetch" href="/blog/assets/js/44.b9fb6912.js"><link rel="prefetch" href="/blog/assets/js/45.87014400.js"><link rel="prefetch" href="/blog/assets/js/5.5939d75c.js"><link rel="prefetch" href="/blog/assets/js/6.5da43515.js"><link rel="prefetch" href="/blog/assets/js/7.ad1cbc2e.js"><link rel="prefetch" href="/blog/assets/js/8.d47f9bc9.js"><link rel="prefetch" href="/blog/assets/js/9.46020f45.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.d244ddc1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">Secret</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/blog/blog/document/swiper.html" class="nav-link">
  技术文档
</a></div><div class="nav-item"><a href="https://google.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  External
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/blog/blog/document/swiper.html" class="nav-link">
  技术文档
</a></div><div class="nav-item"><a href="https://google.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  External
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>技术文档</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/blog/document/swiper.html" class="sidebar-link">一、swiper插件的坑，你了解多少</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/blog/document/swiper.html#引入和基本用法" class="sidebar-link">引入和基本用法</a></li><li class="sidebar-sub-header"><a href="/blog/blog/document/swiper.html#配置选项" class="sidebar-link">配置选项</a></li><li class="sidebar-sub-header"><a href="/blog/blog/document/swiper.html#swiper实例" class="sidebar-link">swiper实例</a></li><li class="sidebar-sub-header"><a href="/blog/blog/document/swiper.html#样式调整" class="sidebar-link">样式调整</a></li><li class="sidebar-sub-header"><a href="/blog/blog/document/swiper.html#sidespreview相关" class="sidebar-link">sidesPreview相关</a></li><li class="sidebar-sub-header"><a href="/blog/blog/document/swiper.html#边距相关" class="sidebar-link">边距相关</a></li><li class="sidebar-sub-header"><a href="/blog/blog/document/swiper.html#loop相关" class="sidebar-link">Loop相关</a></li><li class="sidebar-sub-header"><a href="/blog/blog/document/swiper.html#异步加载" class="sidebar-link">异步加载</a></li></ul></li><li><a href="/blog/blog/document/infiniate.html" class="sidebar-link">二、你真的了解无限加载组件吗？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/blog/document/infiniate.html#总结" class="sidebar-link">总结</a></li><li class="sidebar-sub-header"><a href="/blog/blog/document/infiniate.html#vue-scroller" class="sidebar-link">vue-scroller</a></li><li class="sidebar-sub-header"><a href="/blog/blog/document/infiniate.html#vue-infinite-loading" class="sidebar-link">vue-infinite-loading</a></li><li class="sidebar-sub-header"><a href="/blog/blog/document/infiniate.html#vue-infinite-scroll" class="sidebar-link">vue-infinite-scroll</a></li></ul></li><li><a href="/blog/blog/document/YUIDoc.html" class="sidebar-link">三、YUIDoc不完全指北</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/blog/document/YUIDoc.html#安装" class="sidebar-link">安装</a></li><li class="sidebar-sub-header"><a href="/blog/blog/document/YUIDoc.html#语法" class="sidebar-link">语法</a></li><li class="sidebar-sub-header"><a href="/blog/blog/document/YUIDoc.html#文档生成" class="sidebar-link">文档生成</a></li><li class="sidebar-sub-header"><a href="/blog/blog/document/YUIDoc.html#进展" class="sidebar-link">进展</a></li><li class="sidebar-sub-header"><a href="/blog/blog/document/YUIDoc.html#收获与总结" class="sidebar-link">收获与总结</a></li></ul></li><li><a href="/blog/blog/document/mini.html" class="sidebar-link">四、初识微信小程序</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/blog/document/mini.html#页面调试（自定义编译配置）" class="sidebar-link">页面调试（自定义编译配置）</a></li><li class="sidebar-sub-header"><a href="/blog/blog/document/mini.html#微信小程序生命周期" class="sidebar-link">微信小程序生命周期</a></li><li class="sidebar-sub-header"><a href="/blog/blog/document/mini.html#模板消息（消息推送）" class="sidebar-link">模板消息（消息推送）</a></li><li class="sidebar-sub-header"><a href="/blog/blog/document/mini.html#自定义组件" class="sidebar-link">自定义组件</a></li><li class="sidebar-sub-header"><a href="/blog/blog/document/mini.html#小程序跳转类" class="sidebar-link">小程序跳转类</a></li></ul></li><li><a href="/blog/blog/document/fenxi.html" class="sidebar-link">五、JS循环语句中的性能分析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/blog/document/fenxi.html#描述" class="sidebar-link">描述</a></li><li class="sidebar-sub-header"><a href="/blog/blog/document/fenxi.html#种类" class="sidebar-link">种类</a></li><li class="sidebar-sub-header"><a href="/blog/blog/document/fenxi.html#结论" class="sidebar-link">结论</a></li><li class="sidebar-sub-header"><a href="/blog/blog/document/fenxi.html#附录" class="sidebar-link">附录</a></li></ul></li><li><a href="/blog/blog/document/this.html" class="sidebar-link">六、关于this</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/blog/document/this.html#总结" class="sidebar-link">总结</a></li><li class="sidebar-sub-header"><a href="/blog/blog/document/this.html#this的四种绑定方式" class="sidebar-link">this的四种绑定方式</a></li><li class="sidebar-sub-header"><a href="/blog/blog/document/this.html#优先级" class="sidebar-link">优先级</a></li><li class="sidebar-sub-header"><a href="/blog/blog/document/this.html#例子" class="sidebar-link">例子</a></li></ul></li><li><a href="/blog/blog/document/grid.html" class="sidebar-link">七、CSS grid</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/blog/document/grid.html#容器属性" class="sidebar-link">容器属性</a></li><li class="sidebar-sub-header"><a href="/blog/blog/document/grid.html#项目属性" class="sidebar-link">项目属性</a></li></ul></li><li><a href="/blog/blog/document/fetch.html" class="sidebar-link">八、fetch Api</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/blog/document/fetch.html#与-xmlhttprequest-的异同" class="sidebar-link">与 XMLHttpRequest 的异同</a></li><li class="sidebar-sub-header"><a href="/blog/blog/document/fetch.html#response-对象" class="sidebar-link">Response 对象</a></li><li class="sidebar-sub-header"><a href="/blog/blog/document/fetch.html#request-对象" class="sidebar-link">Request 对象</a></li><li class="sidebar-sub-header"><a href="/blog/blog/document/fetch.html#headers-对象" class="sidebar-link">Headers 对象</a></li></ul></li><li><a href="/blog/blog/document/debounce.html" class="sidebar-link">九、深入理解防抖和节流</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/blog/document/debounce.html#防抖-（debounce）" class="sidebar-link">防抖 （debounce）</a></li><li class="sidebar-sub-header"><a href="/blog/blog/document/debounce.html#节流-（throttle）" class="sidebar-link">节流 （throttle）</a></li><li class="sidebar-sub-header"><a href="/blog/blog/document/debounce.html#应用场景" class="sidebar-link">应用场景</a></li></ul></li><li><a href="/blog/blog/document/application.html" class="active sidebar-link">十、代码之如何实现？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/blog/document/application.html#_1、如何实现数组的扁平化？" class="sidebar-link">1、如何实现数组的扁平化？</a></li><li class="sidebar-sub-header"><a href="/blog/blog/document/application.html#_2、如何实现数组的随机排序？" class="sidebar-link">2、如何实现数组的随机排序？</a></li><li class="sidebar-sub-header"><a href="/blog/blog/document/application.html#_3、js-如何创建一个对象？" class="sidebar-link">3、JS 如何创建一个对象？</a></li><li class="sidebar-sub-header"><a href="/blog/blog/document/application.html#_4、如何实现继承？" class="sidebar-link">4、如何实现继承？</a></li></ul></li><li><a href="/blog/blog/document/css.html" class="sidebar-link">十一、你不知道的CSS</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/blog/document/css.html#_1、position-属性值及其用法" class="sidebar-link">1、position 属性值及其用法</a></li><li class="sidebar-sub-header"><a href="/blog/blog/document/css.html#_2、css-盒模型" class="sidebar-link">2、CSS 盒模型</a></li><li class="sidebar-sub-header"><a href="/blog/blog/document/css.html#_3、伪元素和伪类" class="sidebar-link">3、伪元素和伪类</a></li><li class="sidebar-sub-header"><a href="/blog/blog/document/css.html#_4、居中布局" class="sidebar-link">4、居中布局</a></li><li class="sidebar-sub-header"><a href="/blog/blog/document/css.html#_5、用-css-实现一个三角形" class="sidebar-link">5、用 CSS 实现一个三角形</a></li><li class="sidebar-sub-header"><a href="/blog/blog/document/css.html#_5、一个满屏品字布局如何设计" class="sidebar-link">5、一个满屏品字布局如何设计</a></li><li class="sidebar-sub-header"><a href="/blog/blog/document/css.html#_5、多列等高布局如何实现" class="sidebar-link">5、多列等高布局如何实现</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>深入axios</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Express</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Node.js</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>跨域</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>学习轨迹</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>散文随笔</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="十、代码之如何实现？"><a href="#十、代码之如何实现？" class="header-anchor">#</a> 十、代码之如何实现？</h1> <h2 id="_1、如何实现数组的扁平化？"><a href="#_1、如何实现数组的扁平化？" class="header-anchor">#</a> 1、如何实现数组的扁平化？</h2> <p>什么是数组扁平化？</p> <p>假如说一个数组是这样的。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  let arr = [1,2,3,4,[4,5], [3,4,[4,5]]]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>也就是数组里面嵌套数组，可能有很多层。</p> <p>数组扁平化的意思就是将该数组转化成：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  let brr = [1,2,3,4,4,5,3,4,4,5]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>当然，如果你实现的比较好的话，可以传一个扁平化深度的这样一个参数。</p> <p>扁平化一层就是：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  let crr = [1,2,3,4,4,5,3,4,[4,5]]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>扁平化两层就是 brr 那种形式了。一般默认情况下说数组扁平化就是指完全扁平化。也就是无论嵌套层数多深，都拉平成一维数组。</p> <h3 id="es6-实现"><a href="#es6-实现" class="header-anchor">#</a> ES6 实现</h3> <p>ES6 提供了一个新的 api。Arry.prototype.flat() 用于数组的扁平化，可以传一个参数，指的是拉平多少层。如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  function flat(arr, num = 1) {
    if (Object.prototype.toString.call(arr) !== '[object Array]') throw new Error ('不是数组')
    else return arr.flat(num)
  }
  let arr = [1,2,3,4,[4,5], [3,4,[4,5]]]
  // [1,2,3,4,4,5,3,4,[4,5]]
  console.log(flat(arr))
  // [1,2,3,4,4,5,3,4,4,5]
  console.log(flat(arr, Infinity))
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="递归实现"><a href="#递归实现" class="header-anchor">#</a> 递归实现</h3> <p>使用递归判断否元素为数组，为数组的话递归拉平。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  function flat(arr, res) {
    if (!Array.isArray(arr)) return
    else arr.forEach(i =&gt; Array.isArray(i) ? flat(i, res) : res.push(i))
    return res
  }
  // [1,2,3,4,4,5,3,4,4,5]
  console.log(flat([1,2,3,4,[4,5], [3,4,[4,5]]], []))
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="使用-实现"><a href="#使用-实现" class="header-anchor">#</a> 使用 ... 实现</h3> <p>用 ... 参数将数组一层层展开，直到原数组的每个元素都不为数组</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  function flat (arr) {
    while(arr.some(i =&gt; Array.isArray(i))) {
      arr = [].concat(...arr)
    }
    return arr
  }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>它会修改原数组</p> <h3 id="使用-reduce-实现"><a href="#使用-reduce-实现" class="header-anchor">#</a> 使用 reduce 实现</h3> <p>reduce 只是将写法简化了一点，本质上还是递归的写法</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  const flat = arr =&gt; arr.reduce((prev, next) =&gt; {
    return Array.isArray(next) ? prev.concat(flat(next)) : prev.concat(next)
  }, [])
  // [1,2,3,4,4,5,3,4,4,5]
  console.log(flat([1,2,3,4,[4,5], [3,4,[4,5]]]))
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_2、如何实现数组的随机排序？"><a href="#_2、如何实现数组的随机排序？" class="header-anchor">#</a> 2、如何实现数组的随机排序？</h2> <h3 id="使用-array-sort-方法"><a href="#使用-array-sort-方法" class="header-anchor">#</a> 使用 array.sort() 方法</h3> <p>sort() 方法会对比相邻元素的大小，这里用了 Math.random() 方法，随机置换相邻元素的位置。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  function randomSort(arr) {
    arr.sort(() =&gt; Math.random() &gt; .5 ? 1 : -1)
    return arr
  }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>因为这是对比相邻元素的大小，所以还不够随机。</p> <h3 id="随机索引"><a href="#随机索引" class="header-anchor">#</a> 随机索引</h3> <p>不断去随机删除 arr 里面的元素，并添加到结果数组里，直到数组的长度为 0。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  function randomSort(arr) {
    let res = []
    while(arr.length) {
      let idx = Math.floor(arr.length * Math.random())
      res.push(...arr.splice(idx, 1))
    }
    return res
  }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="洗牌算法"><a href="#洗牌算法" class="header-anchor">#</a> 洗牌算法</h3> <p>针对数组中的每一个元素，该元素与之后的随机位置上的一个元素进行位置对换。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  function randomSort (arr) {
    for (var i = 0; i &lt; arr.length; i++) {
      let idx = Math.floor(Math.random() * (arr.length - i)) + i
      let temp = arr[i]
      arr[i] = arr[idx]
      arr[idx] = temp
    }
    return arr
  }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_3、js-如何创建一个对象？"><a href="#_3、js-如何创建一个对象？" class="header-anchor">#</a> 3、JS 如何创建一个对象？</h2> <p>这个创建对象不是创建 JS 的对象数据类型。而是创建实例的方式。</p> <h3 id="工厂模式"><a href="#工厂模式" class="header-anchor">#</a> 工厂模式</h3> <p>工厂模式就是类似于一个工厂一样，在方法内部创建一个对象，在该对象上定义属性和方法，缺点是无法通过 instanceof 判断该对象由哪个构造函数判断。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  function createObj (name, age) {
    var obj = {}
    obj.name = name
    obj.age = age
    obj.getName = () =&gt; alert(obj.name)
    return obj
  }
  let person = createObj ('yy', 23)
  // yy
  console.log(person.name) 
  // false
  console.log(person instanceof createObj)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h3 id="构造函数模式"><a href="#构造函数模式" class="header-anchor">#</a> 构造函数模式</h3> <p>和工厂模式差不多，不过无需内部创建一个对象。属性和方法定义在 this 上，创建对象时用 new 操作符创建。优点是可以通过 instanceof 操作符判断创建的对象所属的构造函数。缺点是构造函数定义的函数无法做到共用。每次创建一个对象都要在该对象上定义一个函数。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  function CreateObj (name, age) {
    this.name = name
    this.age = age
    this.getName = function () {
      alert(this.name)
    }
  }
  let p = new CreateObj('yy', 23)
  // yy
  p.getName()
  // yy
  console.log(p.name)
  // 23
  console.log(p.age)
  // true
  console.log(p instanceof CreateObj)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h3 id="原型模式"><a href="#原型模式" class="header-anchor">#</a> 原型模式</h3> <p>每个函数都有一个 .prototype 属性，它指该函数的原型，同时该原型对象有个 .constructor 属性指向该构造函数。该函数的实例有个 <em>proto</em> 属性指向该原型对象。当获取某个对象的属性值的时候，先去实例上去找，找不到的话会去该原型对象上去寻找。缺点是所有的属性和方法都是共用的，无法实现对象的特殊化。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  function CreateObjProto () {}
  CreateObjProto.prototype.name = 'yy'
  CreateObjProto.prototype.age = '23'
  CreateObjProto.prototype.getName = function () { alert(this.name) }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>更简洁的原型语法</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  function CreateObjProto () {}
  CreateObjProto.prototype = {
    constructor: CreateObjProto,
    name: 'lucy',
    age: '23',
    getName: function () { alert(this.name) }
  }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="组合模式"><a href="#组合模式" class="header-anchor">#</a> 组合模式</h3> <p>需要共享的属性定义在原型上，否则通过构造函数创建。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  function CreateObj (name, age) {
    this.name = name
    this.age = age
  }
  CreateObj.prototype.getName = function () { alert(this.name) }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="动态原型模式"><a href="#动态原型模式" class="header-anchor">#</a> 动态原型模式</h3> <p>主要是为了解决组合模式看起来不够封装的写法。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  function CreateObj (name, age) {
    this.name = name
    this.age = age
    if (typeof CreateObj.prototype.getName !== 'function') {
      CreateObj.prototype.getName = function () { alert(this.name)  }
    }
  } 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="稳妥构造模式"><a href="#稳妥构造模式" class="header-anchor">#</a> 稳妥构造模式</h3> <p>封装私有方法。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  function CreateObj (name, age) {
    let obj = {}
    obj.age = age
    obj.getName = function () {
      alert(name)
    }
    return obj
  }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>在这个方法中，只有内部的 getName 方法才能访问到传进来的 name 属性。</p> <h2 id="_4、如何实现继承？"><a href="#_4、如何实现继承？" class="header-anchor">#</a> 4、如何实现继承？</h2> <h3 id="原型链继承"><a href="#原型链继承" class="header-anchor">#</a> 原型链继承</h3> <p>将子类的原型重写，指向父类的一个实例，那么子类的实例不仅拥有了在子类实例定义的方法和属性，还拥有了父类实例以及原型上的方法。通过这种方式实现了继承。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  function Parent(name, age) {
    this.name = name
    this.age = age
  }
  Parent.prototype.getName = function () {
    return this.name
  }

  function Child(color) {
    this.color = color
  }
  Child.prototype = new Parent('lucy', 34)
  Child.prototype.getColor = function () {
    return this.color
  }
  let child = new Child('red')
  
  console.log(child)
  console.log(child.getName())
  console.log(child.getColor())
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>缺点：定义在父类原型上的引用类型的值，会被所有的子类实例所共有。改变其值会影响另外一个。</p> <h3 id="构造函数继承"><a href="#构造函数继承" class="header-anchor">#</a> 构造函数继承</h3> <p>借用 call 或者 apply，显式的绑定 this 指代的对象。以达到继承的效果。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  function Parent(name) {
    this.name = name
    this.getName = function (params) {
      return this.name
    }
  }

  function Child(age, name) {
    this.age = age
    // 继承属性和方法
    Parent.call(this, name)
  }

  let Cl = new Child(23, 'Lucy')

  console.log(Cl)

  console.log(Cl.getName())
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>缺点：无法实现函数的复用，每次创建一个对象都要定义 getName 函数。</p> <h3 id="组合继承"><a href="#组合继承" class="header-anchor">#</a> 组合继承</h3> <p>将以上两者的优势结合起来，方法采用原型链继承，属性采用构造函数继承。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  function Parent(color) {
    this.color = color
  }
  Parent.prototype.getColor = function () {
    return this.color
  }

  function Child(name, color) {
    this.name = name
    Parent.call(this, color)
  }

  Child.prototype = new Parent()

  Child.prototype.constructor = Child

  Child.prototype.getName = function (params) {
    return this.name
  }

  let C1 = new Child('Lucy', [2,3,4])
  let C2 = new Child('Lucy', [1,3,4])

  C1.color.push(5)

  console.log(C1.getColor())

  console.log(C1.getName())

  console.log(C2.getColor())

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><h3 id="原型式继承"><a href="#原型式继承" class="header-anchor">#</a> 原型式继承</h3> <p>基于现有的对象创建一个类似的对象，无需大张旗鼓的创建构造函数。ES5 规范了 Object.create() 方法，它的工作原理就是创建一个类似对象，该对象的 <strong>proto</strong> 指向传入的参数对象。一种写法见下面的 create() 方法。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  let Parent = {
    name: 'Lucy',
    getName: function () {
      return this.name
    }
  }

  // Child.__proto__ = Parent
  let Child = Object.create(Parent)
  console.log(Child.getName())

  function create(Obj) {
    let f = new Function()
    f.prototype = Obj
    return new f()
  }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>缺点：引用类型的值会被公用，修改值会影响创建的其他对象。</p> <h3 id="寄生式继承"><a href="#寄生式继承" class="header-anchor">#</a> 寄生式继承</h3> <p>类似于原型式继承，不过会增强该对象。新创建的对象不仅具有原来对象的属性和方法，还有新定义的 getName 方法。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  function Child (parent) {
    let O = Object.create(parent)
    O.getName = function () {
      return this.name
    }
    return O
  }

  let cl = new Child({name: 'xxxxx' })

  console.log(cl.getName())
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="header-anchor">#</a> 寄生组合式继承</h3> <p>原型链继承的时，摒弃将调用父类构造函数创建对象的方式，而是采用 Object.create() 的形式。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  function Parent (name) {
    this.name = name
  }
  Parent.prototype.getName = function () {
    return this.name
  }

  function Child (age, name) {
    this.age = age
    // 继承属性
    Parent.call(this, name)
  }

  Child.prototype = Object.create(Parent.prototype)
  Child.prototype.constructor = Child

  Child.prototype.getAge = function () {
    return this.age
  }

  let cl = new Child(23, 'Lucy')

  console.log(cl.getName())
  console.log(cl.getAge())
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>优点是只需要调用一次构造函数，还能避免在子类原型上创建多余的其他属性和值。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/blog/document/debounce.html" class="prev">
        九、深入理解防抖和节流
      </a></span> <span class="next"><a href="/blog/blog/document/css.html">
        十一、你不知道的CSS
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/blog/assets/js/app.d0f691b7.js" defer></script><script src="/blog/assets/js/2.193d832c.js" defer></script><script src="/blog/assets/js/28.2c3e24f2.js" defer></script>
  </body>
</html>
